"""
Handle user authentication and session management.
"""

from datetime import datetime, timedelta, UTC
from typing import Dict
from jose import JWTError, jwt
from fastapi import HTTPException, status, Request
from src import database
from src.logging import logger
from src.schemas import UserResponse
import os

# JWT configuration
SECRET_KEY = os.getenv("JWT_SECRET_KEY")
if not SECRET_KEY:
    raise ValueError("JWT_SECRET_KEY environment variable is not set")

ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("JWT_EXPIRE_MINUTES", "30"))


def verify_credentials(username: str, password: str) -> UserResponse:
    """
    Verify user credentials against the database.
    Returns UserResponse with user_id, username, and created_at if credentials are valid.
    Raises HTTPException if credentials are invalid.
    """
    with database.connection.cursor() as cur:
        cur.execute(
            "SELECT id, password, created_at FROM users WHERE username = %s",
            (username,),
        )
        result = cur.fetchone()

        if not result:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
            )

        user_id, stored_password, created_at = result

        # Simple password comparison (no hashing for MVP)
        if password == stored_password:
            return UserResponse(
                user_id=user_id, username=username, created_at=created_at
            )

        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid password"
        )


def register_user(username: str, password: str) -> UserResponse:
    """
    Register a new user in the database.
    Returns UserResponse with user_id, username, and created_at if registration is successful.
    Raises HTTPException if username already exists or registration fails.
    """
    with database.connection.cursor() as cur:
        # Check if username already exists
        cur.execute("SELECT id FROM users WHERE username = %s", (username,))
        if cur.fetchone():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already exists",
            )

        # Insert new user into database
        try:
            # user_id and created_at are auto-generated by the database
            cur.execute(
                "INSERT INTO users (username, password) VALUES (%s, %s) RETURNING id, created_at",
                (username, password),
            )
            user_id, created_at = cur.fetchone()
            database.connection.commit()
            return UserResponse(
                user_id=user_id, username=username, created_at=created_at
            )
        except Exception as e:
            # Rolls back changes to database in case of error, to maintain data integrity
            database.connection.rollback()
            logger.error(f"Error registering user: {e}")
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to register user",
            )


def create_access_token(data: UserResponse) -> str:
    """
    Create a JWT access token with the given data and a 30-minute expiration time.
    """
    to_encode = data.model_dump()
    exp = datetime.now(UTC) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode["exp"] = int(exp.timestamp())
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def get_user_from_token(request: Request) -> Dict[str, str | int]:
    """
    Extract and verify user info from JWT token in Authorization header.
    Returns dict with user_id and username if token is valid.
    Raises HTTPException if token is invalid or expired.
    """
    try:
        # Get the Authorization header
        auth_header = request.headers.get("Authorization")
        if not auth_header:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Missing Authorization header",
                headers={"WWW-Authenticate": "Bearer"},
            )

        # Extract token from "Bearer <token>" format
        if not auth_header.startswith("Bearer "):
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Authorization header format",
                headers={"WWW-Authenticate": "Bearer"},
            )

        token = auth_header.split(" ")[1]

        # Rest of the existing token validation code
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id, username, expiration = (
            payload["user_id"],
            payload["username"],
            payload["exp"],
        )
        # Verify valid token payload
        if not username or not user_id or not expiration:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token payload",
                headers={"WWW-Authenticate": "Bearer"},
            )
        # Check if token has expired
        expired = datetime.now(UTC).timestamp() > expiration
        if expired:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Token expired",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return {"user_id": user_id, "username": username}
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )
